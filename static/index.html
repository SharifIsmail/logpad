<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AppendOnly Table</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 14px;
      background: #f5f5f5;
      color: #222;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Toolbar */
    #toolbar {
      background: #1e293b;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    #toolbar-title {
      color: #94a3b8;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      margin-right: auto;
    }
    .toolbar-btn {
      background: #334155;
      color: #e2e8f0;
      border: 1px solid #475569;
      border-radius: 5px;
      padding: 5px 12px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.15s;
    }
    .toolbar-btn:hover:not(:disabled) { background: #475569; }
    .toolbar-btn.primary { background: #3b82f6; border-color: #2563eb; }
    .toolbar-btn.primary:hover:not(:disabled) { background: #2563eb; }
    .toolbar-btn.danger { background: #dc2626; border-color: #b91c1c; }
    .toolbar-btn.danger:hover:not(:disabled) { background: #b91c1c; }
    .toolbar-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    /* App body: sidebar + content */
    #app-body {
      display: flex;
      flex-direction: row;
      flex: 1;
      overflow: hidden;
    }

    /* Table sidebar */
    #table-sidebar {
      width: 200px;
      flex-shrink: 0;
      background: #1e293b;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border-right: 1px solid #334155;
    }
    #sidebar-header {
      padding: 10px 14px;
      color: #64748b;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      border-bottom: 1px solid #334155;
      flex-shrink: 0;
    }
    #table-list {
      flex: 1;
      overflow-y: auto;
      list-style: none;
      padding: 4px 0;
    }
    .table-item {
      display: flex;
      align-items: center;
      padding: 7px 10px;
      cursor: pointer;
      border-radius: 4px;
      margin: 2px 4px;
      color: #94a3b8;
      font-size: 13px;
      gap: 4px;
    }
    .table-item:hover { background: #334155; color: #e2e8f0; }
    .table-item.active { background: #3b82f6; color: white; }
    .table-item-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .btn-table-icon {
      background: none;
      border: none;
      cursor: pointer;
      color: inherit;
      opacity: 0;
      font-size: 13px;
      padding: 2px 4px;
      border-radius: 3px;
      line-height: 1;
    }
    .table-item:hover .btn-table-icon { opacity: 0.6; }
    .table-item:hover .btn-table-icon:hover { opacity: 1; background: rgba(255,255,255,0.15); }
    #sidebar-footer {
      padding: 8px;
      border-top: 1px solid #334155;
      flex-shrink: 0;
    }
    #btn-new-table {
      width: 100%;
      background: transparent;
      color: #64748b;
      border: 1px dashed #475569;
      border-radius: 4px;
      padding: 6px;
      font-size: 12px;
      cursor: pointer;
    }
    #btn-new-table:hover { background: #334155; color: #e2e8f0; border-color: #64748b; }

    /* Main layout */
    #layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Table panel */
    #table-panel {
      flex: 1;
      overflow: auto;
      padding: 16px;
    }

    table {
      border-collapse: collapse;
      background: white;
      width: 100%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border-radius: 6px;
      overflow: hidden;
    }

    th {
      background: #f1f5f9;
      color: #475569;
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      padding: 10px 12px;
      text-align: left;
      border-bottom: 2px solid #e2e8f0;
      white-space: nowrap;
    }
    th.actions-th { color: #94a3b8; }

    td {
      padding: 8px 12px;
      border-bottom: 1px solid #f1f5f9;
      vertical-align: middle;
    }

    tr:last-child td { border-bottom: none; }
    tr:hover td { background: #fafafa; }
    tr.active-history-row td { background: #eff6ff !important; }

    td.cell-editable {
      cursor: text;
      min-width: 120px;
    }
    td.cell-editable:hover { background: #fefce8 !important; }
    td.cell-fk { cursor: pointer; }
    td.cell-fk:hover { background: #f0fdf4 !important; }
    td.cell-stale-fk { color: #dc2626; font-size: 12px; font-style: italic; cursor: pointer; }
    td.cell-stale-fk:hover { background: #fef2f2 !important; }

    td.cell-editing {
      padding: 0;
    }
    td.cell-editing input, td.cell-editing select {
      width: 100%;
      border: 2px solid #3b82f6;
      border-radius: 0;
      padding: 7px 11px;
      font: inherit;
      font-size: 14px;
      outline: none;
      background: #eff6ff;
    }

    td.actions-td {
      white-space: nowrap;
      width: 1%;
    }

    .btn-row-action {
      background: none;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      padding: 3px 8px;
      cursor: pointer;
      font-size: 12px;
      color: #64748b;
      margin-right: 4px;
      transition: all 0.15s;
    }
    .btn-row-action:hover { background: #f1f5f9; color: #1e293b; }
    .btn-row-action.danger { border-color: #fca5a5; color: #dc2626; }
    .btn-row-action.danger:hover { background: #fef2f2; }
    .btn-row-action.active { background: #dbeafe; border-color: #93c5fd; color: #1d4ed8; }

    .col-badge {
      font-size: 9px;
      font-weight: 700;
      vertical-align: super;
      margin-left: 2px;
    }
    .col-badge-u { color: #3b82f6; }
    .col-badge-fk { color: #8b5cf6; }

    #empty-state {
      text-align: center;
      padding: 48px 24px;
      color: #94a3b8;
    }
    #empty-state p { margin-top: 8px; font-size: 13px; }

    #no-table-state {
      text-align: center;
      padding: 48px 24px;
      color: #94a3b8;
    }
    #no-table-state p { margin-top: 8px; font-size: 13px; }

    /* History panel */
    #history-panel {
      width: 340px;
      flex-shrink: 0;
      background: white;
      border-left: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #history-header {
      padding: 12px 16px;
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }
    #history-header h2 { font-size: 13px; font-weight: 600; color: #475569; }
    #history-row-label {
      font-size: 11px;
      color: #94a3b8;
      font-family: monospace;
      margin-top: 2px;
    }
    #btn-history-close {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      color: #94a3b8;
      line-height: 1;
    }
    #btn-history-close:hover { color: #dc2626; }

    #history-list {
      list-style: none;
      overflow-y: auto;
      flex: 1;
      padding: 8px 0;
    }

    #history-list li {
      padding: 8px 16px;
      border-bottom: 1px solid #f8fafc;
    }
    #history-list li:last-child { border-bottom: none; }

    .history-time {
      font-size: 11px;
      color: #94a3b8;
      font-family: monospace;
      display: block;
      margin-bottom: 2px;
    }
    .history-desc { font-size: 13px; color: #334155; }
    .history-desc.sentinel { color: #dc2626; font-style: italic; }
    .history-desc.new-row { color: #16a34a; font-style: italic; }

    /* Cell error flash */
    @keyframes cellErrorFlash {
      0%   { background: #fee2e2; }
      100% { background: transparent; }
    }
    td.cell-error { animation: cellErrorFlash 1.5s ease forwards; outline: 2px solid #dc2626; outline-offset: -2px; }

    /* FK placeholder */
    .cell-fk-empty { color: #94a3b8; font-style: italic; font-size: 13px; }

    /* Typed cells */
    td.cell-bool { cursor: pointer; text-align: center; }
    td.cell-bool:hover { background: #f0fdf4 !important; }
    .cell-bool-toggle { font-size: 18px; line-height: 1; user-select: none; }
    td.cell-number { text-align: right; font-variant-numeric: tabular-nums; }
    td.cell-url a { color: #2563eb; text-decoration: none; font-size: 13px; word-break: break-all; }
    td.cell-url a:hover { text-decoration: underline; }
    td.cell-editing input[type=number] { text-align: right; }
    td.cell-editing input[type=date],
    td.cell-editing input[type=datetime-local] { cursor: pointer; }
    .col-type-badge {
      font-size: 9px; font-weight: 700; vertical-align: super; margin-left: 2px;
      color: #0891b2;
    }
    /* Add-column type selector */
    .add-col-type {
      border: 1px solid #e2e8f0; border-radius: 4px; padding: 6px 8px;
      font: inherit; font-size: 13px; background: white; cursor: pointer; color: #374151;
    }
    .add-col-type:focus { outline: 2px solid #3b82f6; border-color: transparent; }
    /* Select-type choices editor in col modal */
    .col-choices-row {
      display: flex; gap: 6px; align-items: center; margin-top: 4px; flex-wrap: wrap;
    }
    .col-choices-input {
      flex: 1; min-width: 120px; border: 1px solid #e2e8f0; border-radius: 4px;
      padding: 4px 8px; font: inherit; font-size: 12px;
    }
    .col-choices-input:focus { outline: 2px solid #3b82f6; border-color: transparent; }
    .col-type-select {
      border: 1px solid #e2e8f0; border-radius: 4px; padding: 4px 6px;
      font: inherit; font-size: 12px; background: white; cursor: pointer;
    }

    /* Sortable column headers */
    th.sortable { cursor: pointer; user-select: none; }
    th.sortable:hover { background: #e2e8f0; }
    th.sort-asc::after  { content: ' â–²'; font-size: 10px; color: #3b82f6; }
    th.sort-desc::after { content: ' â–¼'; font-size: 10px; color: #3b82f6; }

    /* Inline rename input (sidebar + column header) */
    .inline-rename-input {
      font: inherit; font-size: 13px; background: #1e3a5f; color: white;
      border: 1px solid #3b82f6; border-radius: 3px; padding: 1px 4px;
      outline: none; width: 100%;
    }
    th .inline-rename-input {
      background: white; color: #1e293b; font-size: 13px; padding: 2px 4px; width: 90px;
    }

    /* Row count chip */
    #row-count {
      font-size: 11px; color: #64748b; margin-left: 6px;
      background: #f1f5f9; border: 1px solid #e2e8f0;
      border-radius: 10px; padding: 1px 7px;
    }

    /* Modals */
    dialog {
      border: none;
      border-radius: 8px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.15);
      padding: 0;
      max-width: 520px;
      width: 100%;
    }
    dialog::backdrop { background: rgba(0,0,0,0.4); }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .modal-header h3 { font-size: 15px; font-weight: 600; }
    .modal-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #94a3b8;
      line-height: 1;
    }
    .modal-close:hover { color: #dc2626; }

    .modal-body { padding: 16px 20px; max-height: 60vh; overflow-y: auto; }

    #col-list { list-style: none; }
    #col-list li {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 0;
      border-bottom: 1px solid #f1f5f9;
      flex-wrap: wrap;
    }
    #col-list li:last-child { border-bottom: none; }

    .col-name-input {
      flex: 1;
      min-width: 80px;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 5px 8px;
      font: inherit;
      font-size: 13px;
    }
    .col-name-input:focus { outline: 2px solid #3b82f6; border-color: transparent; }

    .col-action-btn {
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 12px;
      background: white;
      color: #475569;
      transition: all 0.15s;
      white-space: nowrap;
    }
    .col-action-btn:hover { background: #f1f5f9; }
    .col-action-btn.danger { border-color: #fca5a5; color: #dc2626; }
    .col-action-btn.danger:hover { background: #fef2f2; }

    .unique-label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #64748b;
      cursor: pointer;
      white-space: nowrap;
      user-select: none;
    }
    .unique-label input[type=checkbox] { cursor: pointer; }

    .add-col-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .add-col-row input[type=text] {
      flex: 1;
      min-width: 100px;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 6px 10px;
      font: inherit;
      font-size: 13px;
    }
    .add-col-row input[type=text]:focus { outline: 2px solid #3b82f6; border-color: transparent; }
    .add-col-row .add-unique-label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: #64748b;
      white-space: nowrap;
      cursor: pointer;
    }
    .add-col-row button {
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 14px;
      cursor: pointer;
      font-size: 13px;
    }
    .add-col-row button:hover { background: #2563eb; }

    /* Confirm modal */
    #confirm-modal .modal-body { text-align: center; padding: 24px 20px; }
    #confirm-modal p { color: #475569; margin-bottom: 4px; }
    #confirm-modal .row-id-hint { font-family: monospace; font-size: 11px; color: #94a3b8; }
    .confirm-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }

    /* Prompt modal */
    #prompt-modal .modal-body { padding: 20px; }
    #prompt-modal label { display: block; font-size: 13px; color: #475569; margin-bottom: 6px; }
    #prompt-modal input { width: 100%; padding: 7px 10px; border: 1px solid #e2e8f0; border-radius: 4px; font-size: 14px; }
    #prompt-modal input:focus { outline: none; border-color: #3b82f6; }
    #prompt-modal .prompt-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 14px; }
    #prompt-modal .btn-prompt-ok { background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 7px 16px; cursor: pointer; font-size: 13px; }
    #prompt-modal .btn-prompt-ok:hover { background: #2563eb; }
    #prompt-modal .btn-prompt-cancel { background: white; color: #475569; border: 1px solid #e2e8f0; border-radius: 4px; padding: 7px 16px; cursor: pointer; font-size: 13px; }
    #prompt-modal .btn-prompt-cancel:hover { background: #f8fafc; }

    /* General confirm modal */
    #general-confirm-modal .modal-body { padding: 20px; }
    #general-confirm-modal p { color: #475569; font-size: 14px; }
    #general-confirm-modal .confirm-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }
    .btn-confirm-delete {
      background: #dc2626; color: white; border: none; border-radius: 4px;
      padding: 7px 16px; cursor: pointer; font-size: 13px;
    }
    .btn-confirm-delete:hover { background: #b91c1c; }
    .btn-confirm-cancel {
      background: white; color: #475569; border: 1px solid #e2e8f0;
      border-radius: 4px; padding: 7px 16px; cursor: pointer; font-size: 13px;
    }
    .btn-confirm-cancel:hover { background: #f8fafc; }

    /* Relationships modal */
    #fk-list { list-style: none; margin-bottom: 16px; }
    #fk-list li {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 7px 0;
      border-bottom: 1px solid #f1f5f9;
      font-size: 13px;
    }
    #fk-list li:last-child { border-bottom: none; }
    .fk-desc { flex: 1; color: #334155; }
    .fk-arrow { color: #94a3b8; margin: 0 4px; }
    .add-fk-form {
      border-top: 1px solid #e2e8f0;
      padding-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .add-fk-form label { font-size: 12px; font-weight: 600; color: #475569; }
    .add-fk-form select {
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 6px 10px;
      font: inherit;
      font-size: 13px;
    }
    .add-fk-form select:focus { outline: 2px solid #3b82f6; border-color: transparent; }
    .add-fk-form button {
      align-self: flex-end;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 7px 16px;
      cursor: pointer;
      font-size: 13px;
    }
    .add-fk-form button:hover { background: #2563eb; }

    /* Toast */
    #toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 9999;
    }
    .toast {
      background: #1e293b;
      color: #f8fafc;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      animation: slideIn 0.2s ease;
      max-width: 360px;
    }
    .toast.error { background: #dc2626; }
    .toast.success { background: #16a34a; }
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to   { transform: translateX(0);   opacity: 1; }
    }

    #no-cols-hint {
      background: #fffbeb;
      border: 1px solid #fcd34d;
      border-radius: 6px;
      padding: 12px 16px;
      color: #92400e;
      font-size: 13px;
      margin-bottom: 12px;
    }
  </style>
</head>
<body>

<div id="loading-overlay" style="position:fixed;inset:0;background:#1e293b;color:#94a3b8;display:flex;align-items:center;justify-content:center;font-size:18px;z-index:99999">
  Loading databaseâ€¦
</div>

<div id="toolbar">
  <span id="toolbar-title">AppendOnly Table</span>
  <span id="row-count" style="display:none"></span>
  <button class="toolbar-btn primary" id="btn-add-row" disabled>+ Add Row</button>
  <button class="toolbar-btn" id="btn-manage-cols" disabled>Manage Columns</button>
  <button class="toolbar-btn" id="btn-relationships" disabled>Relationships</button>
</div>

<div id="app-body">
  <div id="table-sidebar">
    <div id="sidebar-header">Tables</div>
    <ul id="table-list"></ul>
    <div id="sidebar-footer">
      <button id="btn-new-table">+ New Table</button>
    </div>
  </div>

  <div id="layout">
    <div id="table-panel">
      <div id="no-table-state">
        <strong>No table selected</strong>
        <p>Create a table using the sidebar on the left.</p>
      </div>
      <div id="no-cols-hint" style="display:none">
        No columns defined yet. Click <strong>Manage Columns</strong> to add your first column.
      </div>
      <table id="main-table" style="display:none">
        <thead><tr id="col-headers"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
      <div id="empty-state" style="display:none">
        <strong>No rows yet</strong>
        <p>Click <strong>+ Add Row</strong> to create your first entry.</p>
      </div>
    </div>

    <div id="history-panel" style="display:none">
      <div id="history-header">
        <div>
          <h2>Row History</h2>
          <div id="history-row-label"></div>
        </div>
        <button id="btn-history-close" title="Close history">&times;</button>
      </div>
      <ol id="history-list"></ol>
    </div>
  </div>
</div>

<!-- Column management modal -->
<dialog id="col-modal">
  <div class="modal-header">
    <h3>Manage Columns</h3>
    <button class="modal-close" id="btn-col-modal-close">&times;</button>
  </div>
  <div class="modal-body">
    <ul id="col-list"></ul>
    <div class="add-col-row">
      <input id="new-col-name" type="text" placeholder="New column name&hellip;" />
      <select id="new-col-type" class="add-col-type" title="Column type">
        <option value="text">Text</option>
        <option value="number">Number</option>
        <option value="boolean">Checkbox</option>
        <option value="date">Date</option>
        <option value="datetime">Date &amp; Time</option>
        <option value="url">URL</option>
        <option value="select">Select</option>
      </select>
      <label class="add-unique-label">
        <input id="new-col-unique" type="checkbox" /> Unique
      </label>
      <button id="btn-col-add">Add</button>
    </div>
    <div id="new-col-choices-row" class="col-choices-row" style="display:none">
      <span style="font-size:12px;color:#64748b;white-space:nowrap">Choices (comma-separated):</span>
      <input id="new-col-choices" class="col-choices-input" type="text" placeholder="e.g. Draft, Active, Closed" />
    </div>
  </div>
</dialog>

<!-- Relationships modal -->
<dialog id="relationships-modal">
  <div class="modal-header">
    <h3>Relationships</h3>
    <button class="modal-close" id="btn-rel-modal-close">&times;</button>
  </div>
  <div class="modal-body">
    <p style="font-size:12px;color:#64748b;margin-bottom:14px">
      Foreign key columns store the row UUID of the referenced table's row.
      Editing a FK cell shows a dropdown of available rows.
    </p>
    <ul id="fk-list"></ul>
    <div class="add-fk-form">
      <label>Column in this table</label>
      <select id="fk-from-col"><option value="">â€” select column â€”</option></select>
      <label>References table</label>
      <select id="fk-to-table"><option value="">â€” select table â€”</option></select>
      <button id="btn-fk-add">Add Relationship</button>
    </div>
  </div>
</dialog>

<!-- Delete row confirmation modal -->
<dialog id="confirm-modal">
  <div class="modal-header">
    <h3>Delete Row</h3>
    <button class="modal-close" id="btn-confirm-cancel-x">&times;</button>
  </div>
  <div class="modal-body">
    <p>Are you sure you want to delete this row?</p>
    <p class="row-id-hint" id="confirm-row-hint"></p>
    <p style="font-size:12px;color:#94a3b8;margin-top:8px">The row will be soft-deleted. All history is preserved.</p>
    <div class="confirm-actions">
      <button class="btn-confirm-cancel" id="btn-confirm-no">Cancel</button>
      <button class="btn-confirm-delete" id="btn-confirm-yes">Delete</button>
    </div>
  </div>
</dialog>

<!-- Prompt modal (replaces native prompt()) -->
<dialog id="prompt-modal">
  <div class="modal-header">
    <h3 id="prompt-modal-title">Enter value</h3>
    <button class="modal-close" id="btn-prompt-cancel-x">&times;</button>
  </div>
  <div class="modal-body">
    <label id="prompt-modal-label"></label>
    <input type="text" id="prompt-modal-input" autocomplete="off" />
    <div class="prompt-actions">
      <button class="btn-prompt-cancel" id="btn-prompt-cancel">Cancel</button>
      <button class="btn-prompt-ok" id="btn-prompt-ok">OK</button>
    </div>
  </div>
</dialog>

<!-- General confirm modal (replaces native confirm()) -->
<dialog id="general-confirm-modal">
  <div class="modal-header">
    <h3 id="general-confirm-title">Confirm</h3>
    <button class="modal-close" id="btn-general-confirm-cancel-x">&times;</button>
  </div>
  <div class="modal-body">
    <p id="general-confirm-msg"></p>
    <div class="confirm-actions">
      <button class="btn-confirm-cancel" id="btn-general-confirm-no">Cancel</button>
      <button class="btn-confirm-delete" id="btn-general-confirm-yes">Confirm</button>
    </div>
  </div>
</dialog>

<div id="toast-container"></div>

<script>
// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
const State = {
  tables:       [],
  activeTableId: null,
  columns:      [],
  rows:         [],
  activeRowId:  null,
  foreignKeys:  [],
  fkOptionsMap: {},   // { column_id -> [{row_id, label}] }
};

// ---------------------------------------------------------------------------
// Worker message layer
// ---------------------------------------------------------------------------
const worker = new Worker('./worker.js', { type: 'module' });
const _pending = new Map();
let _msgId = 0;

worker.onmessage = ({ data }) => {
  if (data.type === 'ready') {
    document.getElementById('loading-overlay').style.display = 'none';
    refresh();
    return;
  }
  if (data.type === 'error') {
    document.getElementById('loading-overlay').textContent = 'Failed to load database: ' + data.message;
    return;
  }
  const p = _pending.get(data.id);
  if (!p) return;
  _pending.delete(data.id);
  data.error ? p.reject(new Error(data.error)) : p.resolve(data.result);
};

worker.onerror = (e) => {
  document.getElementById('loading-overlay').textContent = 'Worker error: ' + e.message;
};

function call(type, payload = {}) {
  return new Promise((resolve, reject) => {
    const id = _msgId++;
    _pending.set(id, { resolve, reject });
    worker.postMessage({ id, type, payload });
  });
}

const API = {
  // Tables
  getTables:         ()                            => call('get_tables'),
  addTable:          (name)                        => call('create_table',       { name }),
  renameTable:       (id, name)                    => call('rename_table',       { id, name }),
  deleteTable:       (id)                          => call('delete_table',       { id }),
  // Columns
  getColumns:        ()                            => call('get_columns',        { table_id: State.activeTableId }),
  addColumn:         (name, is_unique, col_type, col_choices) => call('create_column', { table_id: State.activeTableId, name, is_unique, col_type, col_choices }),
  renameColumn:      (id, name)                    => call('rename_column',      { id, name }),
  setColumnUnique:   (id, is_unique)               => call('set_column_unique',  { id, is_unique }),
  setColumnType:     (id, col_type, col_choices)   => call('set_column_type',    { id, col_type, col_choices }),
  deleteColumn:      (id)                          => call('delete_column',      { id }),
  // Rows
  getRows:           ()                            => call('get_rows',           { table_id: State.activeTableId }),
  addRow:            (cells)                       => call('create_row',         { table_id: State.activeTableId, cells }),
  updateRow:         (rowId, cells)                => call('update_row',         { table_id: State.activeTableId, row_id: rowId, cells }),
  deleteRow:         (rowId)                       => call('delete_row',         { table_id: State.activeTableId, row_id: rowId }),
  getHistory:        (rowId)                       => call('get_row_history',    { table_id: State.activeTableId, row_id: rowId }),
  // Foreign keys
  getForeignKeys:    ()                            => call('get_foreign_keys',   { table_id: State.activeTableId }),
  addForeignKey:     (from_column_id, to_table_id) => call('create_foreign_key', { from_column_id, to_table_id }),
  deleteForeignKey:  (id)                          => call('delete_foreign_key', { id }),
  getFkOptions:      (column_id)                   => call('get_fk_options',     { column_id }),
};

// ---------------------------------------------------------------------------
// Toast
// ---------------------------------------------------------------------------
function toast(msg, type = 'error') {
  const container = document.getElementById('toast-container');
  const div = document.createElement('div');
  div.className = `toast ${type}`;
  div.textContent = msg;
  container.appendChild(div);
  setTimeout(() => div.remove(), 4000);
}

// ---------------------------------------------------------------------------
// Sidebar
// ---------------------------------------------------------------------------
function startInlineSidebarRename(li, nameSpan, tableId, currentName) {
  // Hide the span, insert an input in its place
  nameSpan.style.display = 'none';
  const input = document.createElement('input');
  input.className = 'inline-rename-input';
  input.value = currentName;
  li.insertBefore(input, nameSpan);
  input.focus();
  input.select();

  let saved = false;
  const finish = async () => {
    if (saved) return; saved = true;
    const newName = input.value.trim();
    input.remove();
    nameSpan.style.display = '';
    if (!newName || newName === currentName) return;
    try {
      await API.renameTable(tableId, newName);
      await refresh();
      toast(`Table renamed to "${newName}"`, 'success');
    } catch (err) {
      toast(err.message);
    }
  };
  input.addEventListener('blur', finish);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
    if (e.key === 'Escape') {
      saved = true;
      input.remove();
      nameSpan.style.display = '';
    }
  });
}

function renderSidebar() {
  const list = document.getElementById('table-list');
  list.innerHTML = '';

  if (State.tables.length === 0) {
    const li = document.createElement('li');
    li.style.cssText = 'padding:12px 14px;color:#475569;font-size:12px';
    li.textContent = 'No tables yet.';
    list.appendChild(li);
    return;
  }

  for (const tbl of State.tables) {
    const li = document.createElement('li');
    li.className = 'table-item' + (tbl.id === State.activeTableId ? ' active' : '');
    li.dataset.tableId = tbl.id;

    const nameSpan = document.createElement('span');
    nameSpan.className = 'table-item-name';
    nameSpan.textContent = tbl.name;

    const renameBtn = document.createElement('button');
    renameBtn.className = 'btn-table-icon';
    renameBtn.title = 'Rename';
    renameBtn.textContent = 'âœŽ';
    renameBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      startInlineSidebarRename(li, nameSpan, tbl.id, tbl.name);
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'btn-table-icon';
    deleteBtn.title = 'Delete';
    deleteBtn.textContent = 'Ã—';
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      promptDeleteTable(tbl.id, tbl.name);
    });

    li.append(nameSpan, renameBtn, deleteBtn);

    // Single click on nameSpan switches table instantly; li catches clicks outside nameSpan too
    nameSpan.addEventListener('click', (e) => {
      e.stopPropagation();
      switchTable(tbl.id);
    });
    li.addEventListener('click', () => switchTable(tbl.id));
    list.appendChild(li);
  }
}

async function switchTable(tableId) {
  if (State.activeTableId === tableId) return;
  closeHistory();
  State.activeTableId = tableId;
  _updateToolbarTitle();
  _setActionButtonsDisabled(false);
  await refresh();
}

function _updateToolbarTitle() {
  const tbl = State.tables.find(t => t.id === State.activeTableId);
  document.getElementById('toolbar-title').textContent =
    tbl ? `AppendOnly \u2014 ${tbl.name}` : 'AppendOnly Table';
}

function _setActionButtonsDisabled(disabled) {
  document.getElementById('btn-add-row').disabled       = disabled;
  document.getElementById('btn-manage-cols').disabled   = disabled;
  document.getElementById('btn-relationships').disabled = disabled;
}

// ---------------------------------------------------------------------------
// Prompt / confirm helpers (no native dialogs â€” they disconnect the extension)
// ---------------------------------------------------------------------------
function showPrompt(title, label, defaultValue = '') {
  return new Promise((resolve) => {
    const modal = document.getElementById('prompt-modal');
    const input = document.getElementById('prompt-modal-input');
    document.getElementById('prompt-modal-title').textContent = title;
    document.getElementById('prompt-modal-label').textContent = label;
    input.value = defaultValue;
    modal.showModal();
    requestAnimationFrame(() => { input.focus(); input.select(); });

    const cleanup = (value) => {
      modal.close();
      okBtn.removeEventListener('click', onOk);
      cancelBtn.removeEventListener('click', onCancel);
      cancelX.removeEventListener('click', onCancel);
      input.removeEventListener('keydown', onKey);
      // Blur active element so Enter doesn't re-trigger the button that opened this modal
      if (document.activeElement) document.activeElement.blur();
      resolve(value);
    };
    const onOk = () => cleanup(input.value.trim() || null);
    const onCancel = () => cleanup(null);
    const onKey = (e) => {
      if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); onOk(); }
      if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); onCancel(); }
    };

    const okBtn     = document.getElementById('btn-prompt-ok');
    const cancelBtn = document.getElementById('btn-prompt-cancel');
    const cancelX   = document.getElementById('btn-prompt-cancel-x');
    okBtn.addEventListener('click', onOk);
    cancelBtn.addEventListener('click', onCancel);
    cancelX.addEventListener('click', onCancel);
    input.addEventListener('keydown', onKey);
  });
}

function showConfirm(title, message, confirmLabel = 'Confirm', danger = false) {
  return new Promise((resolve) => {
    const modal  = document.getElementById('general-confirm-modal');
    const yesBtn = document.getElementById('btn-general-confirm-yes');
    document.getElementById('general-confirm-title').textContent = title;
    document.getElementById('general-confirm-msg').textContent   = message;
    yesBtn.textContent = confirmLabel;
    yesBtn.style.background = danger ? '#dc2626' : '#3b82f6';
    yesBtn.style.borderColor = danger ? '#b91c1c' : '#2563eb';
    modal.showModal();

    const cleanup = (value) => {
      modal.close();
      yesBtn.removeEventListener('click', onYes);
      noBtn.removeEventListener('click', onNo);
      cancelX.removeEventListener('click', onNo);
      resolve(value);
    };
    const onYes = () => cleanup(true);
    const onNo  = () => cleanup(false);

    const noBtn   = document.getElementById('btn-general-confirm-no');
    const cancelX = document.getElementById('btn-general-confirm-cancel-x');
    yesBtn.addEventListener('click', onYes);
    noBtn.addEventListener('click', onNo);
    cancelX.addEventListener('click', onNo);
  });
}

document.getElementById('btn-new-table').addEventListener('click', async () => {
  const name = await showPrompt('New Table', 'Table name:');
  if (!name) return;
  try {
    const result = await API.addTable(name);
    State.activeTableId = result.id;
    _setActionButtonsDisabled(false);
    await refresh();
    toast(`Table "${name}" created`, 'success');
  } catch (err) {
    toast(err.message);
  }
});

async function promptRenameTable(id, currentName) {
  const newName = await showPrompt(`Rename Table`, 'New name:', currentName);
  if (!newName || newName === currentName) return;
  try {
    await API.renameTable(id, newName);
    await refresh();
    toast(`Table renamed to "${newName}"`, 'success');
  } catch (err) {
    toast(err.message);
  }
}

async function promptDeleteTable(id, name) {
  const ok = await showConfirm(
    'Delete Table',
    `Delete table "${name}"? All columns will be soft-deleted. You must delete all rows first.`,
    'Delete', true
  );
  if (!ok) return;
  try {
    if (State.activeTableId === id) {
      State.activeTableId = null;
      _setActionButtonsDisabled(true);
    }
    await API.deleteTable(id);
    await refresh();
    toast(`Table "${name}" deleted`, 'success');
  } catch (err) {
    toast(err.message);
  }
}

// ---------------------------------------------------------------------------
// Sort state
// ---------------------------------------------------------------------------
const SortState = { colName: null, dir: 'asc' }; // dir: 'asc' | 'desc'

// Pending Tab navigation: set before blur/save, consumed by renderTable after next render
let _pendingTabNav = null; // { rowId, cellIdx } | null

function _sortedRows(rows) {
  if (!SortState.colName) return rows;
  return [...rows].sort((a, b) => {
    const av = (a.cells[SortState.colName] ?? '').toLowerCase();
    const bv = (b.cells[SortState.colName] ?? '').toLowerCase();
    if (av < bv) return SortState.dir === 'asc' ? -1 : 1;
    if (av > bv) return SortState.dir === 'asc' ? 1 : -1;
    return 0;
  });
}

// ---------------------------------------------------------------------------
// Inline column rename
// ---------------------------------------------------------------------------
function startInlineColRename(th, col) {
  // Replace th content with an input
  const oldHTML = th.innerHTML;
  th.innerHTML = '';
  const input = document.createElement('input');
  input.className = 'inline-rename-input';
  input.value = col.name;
  th.appendChild(input);
  input.focus();
  input.select();

  let saved = false;
  const finish = async () => {
    if (saved) return;
    saved = true;
    const newName = input.value.trim();
    if (!newName || newName === col.name) { renderTable(); return; }
    try {
      await API.renameColumn(col.id, newName);
      await refresh();
      toast(`Column renamed to "${newName}"`, 'success');
    } catch (err) {
      toast(err.message);
      renderTable();
    }
  };
  input.addEventListener('blur', finish);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
    if (e.key === 'Escape') { saved = true; renderTable(); }
  });
}

// ---------------------------------------------------------------------------
// Render table
// ---------------------------------------------------------------------------
function renderTable() {
  const { columns, foreignKeys } = State;
  const rows = _sortedRows(State.rows);
  const { activeRowId } = State;

  const noTableState = document.getElementById('no-table-state');
  const noColsHint   = document.getElementById('no-cols-hint');
  const mainTable    = document.getElementById('main-table');
  const emptyState   = document.getElementById('empty-state');
  const rowCountEl   = document.getElementById('row-count');

  if (State.activeTableId === null) {
    noTableState.style.display = '';
    noColsHint.style.display   = 'none';
    mainTable.style.display    = 'none';
    emptyState.style.display   = 'none';
    rowCountEl.style.display   = 'none';
    return;
  }
  noTableState.style.display = 'none';

  if (columns.length === 0) {
    noColsHint.style.display = 'block';
    mainTable.style.display  = 'none';
    emptyState.style.display = 'none';
    rowCountEl.style.display = 'none';
    return;
  }
  noColsHint.style.display = 'none';
  mainTable.style.display  = '';

  // Row count chip
  rowCountEl.style.display = '';
  rowCountEl.textContent = `${State.rows.length} row${State.rows.length !== 1 ? 's' : ''}`;

  if (rows.length === 0) {
    emptyState.style.display = 'block';
  } else {
    emptyState.style.display = 'none';
  }

  // Header â€” sortable + double-click to rename
  const headerRow = document.getElementById('col-headers');
  headerRow.innerHTML = '';
  for (const col of columns) {
    const th = document.createElement('th');
    th.className = 'sortable';
    th.dataset.colName = col.name;
    if (SortState.colName === col.name) {
      th.classList.add(SortState.dir === 'asc' ? 'sort-asc' : 'sort-desc');
    }

    const nameText = document.createTextNode(col.name);
    th.appendChild(nameText);

    if (col.is_unique) {
      const b = document.createElement('span');
      b.className = 'col-badge col-badge-u';
      b.title = 'Unique constraint';
      b.textContent = 'U';
      th.appendChild(b);
    }
    const fkDef = foreignKeys.find(fk => fk.from_column_id === col.id);
    if (fkDef) {
      const b = document.createElement('span');
      b.className = 'col-badge col-badge-fk';
      b.title = `FK â†’ ${fkDef.to_table_name}`;
      b.textContent = 'FK';
      th.appendChild(b);
    }
    // Type badge (skip for plain text, skip if FK already shown)
    const colType = col.col_type || 'text';
    if (colType !== 'text' && !fkDef) {
      const typeLabels = { number: '#', boolean: 'âœ“', date: 'ðŸ“…', datetime: 'ðŸ•', url: 'ðŸ”—', select: 'â–¾' };
      const b = document.createElement('span');
      b.className = 'col-type-badge';
      b.title = colType.charAt(0).toUpperCase() + colType.slice(1) + ' column';
      b.textContent = typeLabels[colType] || colType;
      th.appendChild(b);
    }

    // Single click â†’ sort (delayed so dblclick can cancel it)
    let _sortTimer = null;
    th.addEventListener('click', () => {
      clearTimeout(_sortTimer);
      _sortTimer = setTimeout(() => {
        if (SortState.colName === col.name) {
          SortState.dir = SortState.dir === 'asc' ? 'desc' : 'asc';
        } else {
          SortState.colName = col.name;
          SortState.dir = 'asc';
        }
        renderTable();
      }, 220);
    });

    // Double click â†’ inline rename (cancels pending sort)
    th.addEventListener('dblclick', (e) => {
      e.stopPropagation();
      clearTimeout(_sortTimer);
      startInlineColRename(th, col);
    });

    headerRow.appendChild(th);
  }
  const actTh = document.createElement('th');
  actTh.className = 'actions-th';
  actTh.textContent = 'Actions';
  headerRow.appendChild(actTh);

  // Body
  const tbody = document.getElementById('table-body');
  tbody.innerHTML = '';

  for (const row of rows) {
    const tr = document.createElement('tr');
    tr.dataset.rowId = row.row_id;
    if (row.row_id === activeRowId) tr.classList.add('active-history-row');

    for (const col of columns) {
      const td = document.createElement('td');
      td.dataset.colName = col.name;
      td.dataset.colId   = col.id;
      td.dataset.rowId   = row.row_id;

      const fkDef = foreignKeys.find(fk => fk.from_column_id === col.id);
      const rawValue = row.cells[col.name] ?? '';

      if (fkDef) {
        td.dataset.isFk = 'true';
        const options = State.fkOptionsMap[col.id] || [];
        const match = options.find(o => o.row_id === rawValue);
        if (rawValue && !match) {
          td.className = 'cell-stale-fk';
          td.title = `Stale reference: ${rawValue}`;
          td.textContent = rawValue.slice(0, 8) + 'â€¦ (deleted)';
        } else if (match) {
          td.className = 'cell-editable cell-fk';
          td.textContent = match.label ?? rawValue.slice(0, 8) + 'â€¦';
        } else {
          // Empty FK â€” show placeholder
          td.className = 'cell-editable cell-fk';
          const ph = document.createElement('span');
          ph.className = 'cell-fk-empty';
          ph.textContent = 'â€” select â€”';
          td.appendChild(ph);
        }
      } else {
        // Typed (non-FK) cell rendering
        const colType = col.col_type || 'text';
        if (colType === 'boolean') {
          td.className = 'cell-bool cell-editable';
          td.dataset.colType = 'boolean';
          const isChecked = rawValue === '1' || rawValue === 'true';
          const toggle = document.createElement('span');
          toggle.className = 'cell-bool-toggle';
          toggle.textContent = isChecked ? 'â˜‘' : 'â˜';
          toggle.title = isChecked ? 'True â€” click to toggle' : 'False â€” click to toggle';
          td.appendChild(toggle);
        } else if (colType === 'url') {
          td.className = 'cell-url cell-editable';
          td.dataset.colType = 'url';
          if (rawValue) {
            const a = document.createElement('a');
            a.href = rawValue;
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            a.textContent = rawValue;
            a.addEventListener('click', (e) => e.stopPropagation());
            td.appendChild(a);
          }
        } else if (colType === 'date') {
          td.className = 'cell-editable';
          td.dataset.colType = 'date';
          // Display as locale date string; store as ISO YYYY-MM-DD
          td.textContent = rawValue
            ? new Date(rawValue + 'T00:00:00').toLocaleDateString()
            : '';
        } else if (colType === 'datetime') {
          td.className = 'cell-editable';
          td.dataset.colType = 'datetime';
          td.textContent = rawValue
            ? new Date(rawValue).toLocaleString()
            : '';
        } else if (colType === 'number') {
          td.className = 'cell-number cell-editable';
          td.dataset.colType = 'number';
          td.textContent = rawValue;
        } else if (colType === 'select') {
          td.className = 'cell-editable cell-fk'; // reuse FK cursor style
          td.dataset.colType = 'select';
          td.dataset.colChoices = col.col_choices || '';
          if (rawValue) {
            td.textContent = rawValue;
          } else {
            const ph = document.createElement('span');
            ph.className = 'cell-fk-empty';
            ph.textContent = 'â€” select â€”';
            td.appendChild(ph);
          }
        } else {
          td.className = 'cell-editable';
          td.dataset.colType = 'text';
          td.textContent = rawValue;
        }
      }

      td.addEventListener('click', startCellEdit);
      tr.appendChild(td);
    }

    // Actions cell
    const actTd = document.createElement('td');
    actTd.className = 'actions-td';

    const histBtn = document.createElement('button');
    histBtn.className = 'btn-row-action' + (row.row_id === activeRowId ? ' active' : '');
    histBtn.textContent = 'History';
    histBtn.addEventListener('click', () => openHistory(row.row_id));
    actTd.appendChild(histBtn);

    const delBtn = document.createElement('button');
    delBtn.className = 'btn-row-action danger';
    delBtn.textContent = 'Delete';
    delBtn.addEventListener('click', () => confirmDeleteRow(row.row_id));
    actTd.appendChild(delBtn);

    tr.appendChild(actTd);
    tbody.appendChild(tr);
  }

  // Consume any pending Tab navigation set before the last save+refresh
  if (_pendingTabNav) {
    const { rowId: navRowId, cellIdx } = _pendingTabNav;
    _pendingTabNav = null;
    const navRow = [...tbody.querySelectorAll('tr')].find(tr => tr.dataset.rowId === navRowId);
    if (navRow) {
      const allTds = [...navRow.querySelectorAll('td')];
      const fkCells = [...navRow.querySelectorAll('td.cell-fk')];
      const editOnlyCells = [...navRow.querySelectorAll('td.cell-editable:not(.cell-fk)')];
      const uniqueCells = [...new Set([...fkCells, ...editOnlyCells])]
        .sort((a, b) => allTds.indexOf(a) - allTds.indexOf(b));
      const target = uniqueCells[cellIdx];
      if (target) requestAnimationFrame(() => target.click());
    }
  }
}

// ---------------------------------------------------------------------------
// Inline cell editing
// ---------------------------------------------------------------------------
async function startCellEdit(event) {
  const td = event.currentTarget;
  if (td.classList.contains('cell-editing')) return;

  const isFk = td.dataset.isFk === 'true';
  const colId = parseInt(td.dataset.colId);
  const colName = td.dataset.colName;
  const rowId = td.dataset.rowId;

  // Raw value from state
  const rowObj = State.rows.find(r => r.row_id === rowId);
  const currentRawValue = rowObj ? (rowObj.cells[colName] ?? '') : '';

  // Boolean: instant toggle without entering edit mode
  if (!isFk && (td.dataset.colType || 'text') === 'boolean') {
    const wasChecked = currentRawValue === '1' || currentRawValue === 'true';
    const newValue = wasChecked ? '0' : '1';
    try {
      await API.updateRow(rowId, { [colName]: newValue });
      await refresh();
      if (State.activeRowId === rowId) await loadHistory(rowId);
    } catch (err) {
      toast(err.message);
      await refresh();
    }
    return;
  }

  td.classList.add('cell-editing');
  td.classList.remove('cell-editable', 'cell-fk', 'cell-stale-fk', 'cell-bool', 'cell-number', 'cell-url');
  td.textContent = '';

  if (isFk) {
    const select = document.createElement('select');
    select.style.cssText = 'width:100%;border:2px solid #3b82f6;padding:6px 8px;font:inherit;font-size:14px;outline:none;background:#eff6ff;cursor:pointer';

    const blankOpt = document.createElement('option');
    blankOpt.value = '';
    blankOpt.textContent = 'â€” none â€”';
    select.appendChild(blankOpt);

    const options = State.fkOptionsMap[colId] || [];
    for (const opt of options) {
      const o = document.createElement('option');
      o.value = opt.row_id;
      o.textContent = opt.label ?? opt.row_id.slice(0, 8) + 'â€¦';
      if (opt.row_id === currentRawValue) o.selected = true;
      select.appendChild(o);
    }
    // If current value is stale (not in options), add it as a disabled option
    if (currentRawValue && !options.find(o => o.row_id === currentRawValue)) {
      const stale = document.createElement('option');
      stale.value = currentRawValue;
      stale.textContent = currentRawValue.slice(0, 8) + 'â€¦ (deleted)';
      stale.selected = true;
      select.insertBefore(stale, select.children[1]);
    }

    td.appendChild(select);
    select.focus();

    let saved = false;

    function restoreDisplay(rawVal) {
      td.classList.remove('cell-editing');
      const opts = State.fkOptionsMap[colId] || [];
      const m = opts.find(o => o.row_id === rawVal);
      if (rawVal && !m) {
        td.className = 'cell-stale-fk';
        td.title = `Stale reference: ${rawVal}`;
        td.textContent = rawVal.slice(0, 8) + 'â€¦ (deleted)';
      } else {
        td.className = 'cell-editable cell-fk';
        td.dataset.isFk = 'true';
        td.textContent = m ? (m.label ?? rawVal.slice(0, 8) + 'â€¦') : '';
      }
      td.addEventListener('click', startCellEdit);
    }

    async function saveFkEdit() {
      if (saved) return;
      saved = true;
      const newValue = select.value;
      if (newValue === currentRawValue) {
        restoreDisplay(currentRawValue);
        return;
      }
      try {
        await API.updateRow(rowId, { [colName]: newValue });
        await refresh();
        if (State.activeRowId === rowId) await loadHistory(rowId);
      } catch (err) {
        restoreDisplay(currentRawValue);
        toast(err.message);
      }
    }

    select.addEventListener('blur', saveFkEdit);
    select.addEventListener('change', () => select.blur());
    select.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        saved = true;
        restoreDisplay(currentRawValue);
      }
    });

  } else {
    const colType = td.dataset.colType || 'text';

    // --- Select: dropdown of predefined choices ---
    if (colType === 'select') {
      const choicesRaw = td.dataset.colChoices || '';
      const choices = choicesRaw.split(',').map(s => s.trim()).filter(Boolean);
      const select = document.createElement('select');
      select.style.cssText = 'width:100%;border:2px solid #3b82f6;padding:6px 8px;font:inherit;font-size:14px;outline:none;background:#eff6ff;cursor:pointer';

      const blankOpt = document.createElement('option');
      blankOpt.value = '';
      blankOpt.textContent = 'â€” none â€”';
      select.appendChild(blankOpt);

      for (const choice of choices) {
        const o = document.createElement('option');
        o.value = choice;
        o.textContent = choice;
        if (choice === currentRawValue) o.selected = true;
        select.appendChild(o);
      }
      if (!select.value && currentRawValue) {
        // Value not in choices â€” show it as a fallback
        const o = document.createElement('option');
        o.value = currentRawValue;
        o.textContent = currentRawValue + ' (custom)';
        o.selected = true;
        select.appendChild(o);
      }
      if (!currentRawValue) select.value = '';
      td.appendChild(select);
      select.focus();

      let savedSel = false;
      async function saveSelectEdit() {
        if (savedSel) return; savedSel = true;
        const newValue = select.value;
        td.classList.remove('cell-editing');
        td.classList.add('cell-editable', 'cell-fk');
        td.textContent = '';
        if (newValue === currentRawValue) {
          if (newValue) { td.textContent = newValue; }
          else { const ph = document.createElement('span'); ph.className='cell-fk-empty'; ph.textContent='â€” select â€”'; td.appendChild(ph); }
          td.addEventListener('click', startCellEdit);
          return;
        }
        try {
          await API.updateRow(rowId, { [colName]: newValue });
          await refresh();
          if (State.activeRowId === rowId) await loadHistory(rowId);
        } catch (err) {
          toast(err.message);
          await refresh();
        }
      }
      select.addEventListener('blur', saveSelectEdit);
      select.addEventListener('change', () => select.blur());
      select.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') { savedSel = true; td.classList.remove('cell-editing'); td.classList.add('cell-editable','cell-fk'); td.textContent = currentRawValue || ''; td.addEventListener('click', startCellEdit); }
      });
      return;
    }

    // --- All other types: input element with appropriate type ---
    const input = document.createElement('input');
    if (colType === 'number') {
      input.type = 'number';
      input.step = 'any';
    } else if (colType === 'date') {
      input.type = 'date';
    } else if (colType === 'datetime') {
      input.type = 'datetime-local';
      input.step = '1';
    } else if (colType === 'url') {
      input.type = 'url';
    } else {
      input.type = 'text';
    }
    input.value = currentRawValue;
    td.appendChild(input);
    input.focus();
    if (input.select) input.select();

    let saved = false;

    async function saveEdit() {
      if (saved) return;
      saved = true;
      let newValue = input.value;

      // Validate number
      if (colType === 'number' && newValue !== '' && isNaN(Number(newValue))) {
        toast('Must be a valid number');
        saved = false;
        input.focus();
        return;
      }

      td.classList.remove('cell-editing');
      td.classList.add('cell-editable');
      if (colType === 'number') td.classList.add('cell-number');
      if (colType === 'url') td.classList.add('cell-url');

      if (newValue === currentRawValue) {
        // Re-render the cell properly
        await refresh();
        return;
      }

      td.textContent = newValue;
      try {
        await API.updateRow(rowId, { [colName]: newValue });
        await refresh();
        if (State.activeRowId === rowId) await loadHistory(rowId);
      } catch (err) {
        _pendingTabNav = null;
        td.textContent = currentRawValue;
        td.classList.add('cell-error');
        td.addEventListener('animationend', () => td.classList.remove('cell-error'), { once: true });
        toast(err.message);
        await refresh();
      }
    }

    input.addEventListener('blur', saveEdit);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
      if (e.key === 'Tab') {
        e.preventDefault();
        const allTds = [...td.parentElement.querySelectorAll('td')];
        const interactiveTds = allTds.filter(t =>
          t.classList.contains('cell-fk') ||
          t.classList.contains('cell-editable') ||
          t.classList.contains('cell-editing')
        );
        const uniqueCells = [...new Set(interactiveTds)];
        const currentIdx = uniqueCells.indexOf(td);
        const nextIdx = e.shiftKey ? currentIdx - 1 : currentIdx + 1;
        if (currentIdx >= 0 && nextIdx >= 0 && nextIdx < uniqueCells.length) {
          _pendingTabNav = { rowId, cellIdx: nextIdx };
        }
        input.blur();
      }
      if (e.key === 'Escape') {
        saved = true;
        td.classList.remove('cell-editing');
        td.classList.add('cell-editable');
        td.textContent = currentRawValue;
        td.addEventListener('click', startCellEdit);
      }
    });
  }
}

// ---------------------------------------------------------------------------
// Add row
// ---------------------------------------------------------------------------
document.getElementById('btn-add-row').addEventListener('click', async () => {
  if (!State.activeTableId) return;
  try {
    await API.addRow({});
    await refresh();
    toast('Row added', 'success');
    // Auto-focus the first editable cell of the new (last) row
    const rows = document.querySelectorAll('#table-body tr');
    if (rows.length > 0) {
      const lastRow = rows[rows.length - 1];
      const firstCell = lastRow.querySelector('td.cell-editable, td.cell-fk');
      if (firstCell) firstCell.click();
    }
  } catch (err) {
    toast(err.message);
  }
});

// ---------------------------------------------------------------------------
// Delete row
// ---------------------------------------------------------------------------
let _pendingDeleteRowId = null;

function confirmDeleteRow(rowId) {
  _pendingDeleteRowId = rowId;
  document.getElementById('confirm-row-hint').textContent = `ID: ${rowId}`;
  document.getElementById('confirm-modal').showModal();
}

document.getElementById('btn-confirm-yes').addEventListener('click', async () => {
  const rowId = _pendingDeleteRowId;
  document.getElementById('confirm-modal').close();
  try {
    await API.deleteRow(rowId);
    if (State.activeRowId === rowId) closeHistory();
    await refresh();
    toast('Row deleted', 'success');
  } catch (err) {
    toast(err.message);
  }
});

document.getElementById('btn-confirm-no').addEventListener('click', () => {
  document.getElementById('confirm-modal').close();
});
document.getElementById('btn-confirm-cancel-x').addEventListener('click', () => {
  document.getElementById('confirm-modal').close();
});

// ---------------------------------------------------------------------------
// History panel
// ---------------------------------------------------------------------------
function _rowLabel(rowId) {
  // Find the first non-empty cell value for this row to use as a display label
  const row = State.rows.find(r => r.row_id === rowId);
  if (!row) return rowId.slice(0, 8) + 'â€¦';
  for (const col of State.columns) {
    const val = row.cells[col.name];
    if (val && val.trim()) {
      // For FK columns, resolve to label
      const fkDef = State.foreignKeys.find(fk => fk.from_column_id === col.id);
      if (fkDef) {
        const opts = State.fkOptionsMap[fkDef.from_column_id] || [];
        const m = opts.find(o => o.row_id === val);
        return m ? m.label : val.slice(0, 8) + 'â€¦';
      }
      return val;
    }
  }
  return rowId.slice(0, 8) + 'â€¦';
}

function _relativeTime(date) {
  const secs = Math.round((Date.now() - date.getTime()) / 1000);
  if (secs < 60)  return `${secs}s ago`;
  const mins = Math.round(secs / 60);
  if (mins < 60)  return `${mins}m ago`;
  const hrs = Math.round(mins / 60);
  if (hrs < 24)   return `${hrs}h ago`;
  const days = Math.round(hrs / 24);
  return `${days}d ago`;
}

async function openHistory(rowId) {
  State.activeRowId = rowId;
  document.getElementById('history-panel').style.display = 'flex';
  document.getElementById('history-panel').style.flexDirection = 'column';
  document.getElementById('history-row-label').textContent = _rowLabel(rowId);
  renderTable();
  await loadHistory(rowId);
}

async function loadHistory(rowId) {
  const list = document.getElementById('history-list');
  list.innerHTML = '<li style="padding:8px 16px;color:#94a3b8;font-size:12px">Loading&hellip;</li>';
  try {
    const history = await API.getHistory(rowId);
    list.innerHTML = '';
    for (const entry of [...history].reverse()) {
      const li = document.createElement('li');

      const timeSpan = document.createElement('span');
      timeSpan.className = 'history-time';
      const ts = entry.timestamp.endsWith('Z') ? entry.timestamp : entry.timestamp + 'Z';
      const dateObj = new Date(ts);
      timeSpan.textContent = dateObj.toLocaleString();
      timeSpan.title = _relativeTime(dateObj);
      li.appendChild(timeSpan);

      const desc = document.createElement('span');
      const sentinel = entry.sentinel;
      if (sentinel === '__deleted__') {
        desc.className = 'history-desc sentinel';
        desc.textContent = entry.value === '1' ? 'Row deleted' : 'Row restored';
      } else if (sentinel === '__new__') {
        desc.className = 'history-desc new-row';
        desc.textContent = 'Row created';
      } else {
        desc.className = 'history-desc';
        const col = entry.column_name || '(deleted column)';
        let displayVal;
        if (entry.value === null) {
          displayVal = '(cleared)';
        } else {
          // Resolve FK UUID â†’ label using the same fkOptionsMap as the table cells
          const fkDef = State.foreignKeys.find(fk => fk.from_column_name === entry.column_name);
          if (fkDef) {
            const options = State.fkOptionsMap[fkDef.from_column_id] || [];
            const match = options.find(o => o.row_id === entry.value);
            displayVal = match
              ? `"${match.label ?? entry.value.slice(0, 8) + '\u2026'}"`
              : `"${entry.value.slice(0, 8)}\u2026 (deleted)"`;
          } else {
            displayVal = `"${entry.value}"`;
          }
        }
        desc.textContent = `${col} \u2192 ${displayVal}`;
      }
      li.appendChild(desc);
      list.appendChild(li);
    }
    if (history.length === 0) {
      list.innerHTML = '<li style="padding:8px 16px;color:#94a3b8;font-size:12px">No history found.</li>';
    }
  } catch (err) {
    list.innerHTML = `<li style="padding:8px 16px;color:#dc2626;font-size:12px">${err.message}</li>`;
  }
}

function closeHistory() {
  State.activeRowId = null;
  document.getElementById('history-panel').style.display = 'none';
  renderTable();
}

document.getElementById('btn-history-close').addEventListener('click', closeHistory);

// ---------------------------------------------------------------------------
// Column management modal
// ---------------------------------------------------------------------------
function renderColModal() {
  const list = document.getElementById('col-list');
  list.innerHTML = '';

  if (State.columns.length === 0) {
    const li = document.createElement('li');
    li.style.cssText = 'padding:12px 0;color:#94a3b8;font-size:13px;border:none';
    li.textContent = 'No columns yet. Add one below.';
    list.appendChild(li);
    return;
  }

  for (const col of State.columns) {
    const li = document.createElement('li');

    const nameInput = document.createElement('input');
    nameInput.type      = 'text';
    nameInput.value     = col.name;
    nameInput.className = 'col-name-input';

    const renameBtn = document.createElement('button');
    renameBtn.textContent = 'Rename';
    renameBtn.className   = 'col-action-btn';
    renameBtn.addEventListener('click', async () => {
      const newName = nameInput.value.trim();
      if (!newName || newName === col.name) return;
      try {
        await API.renameColumn(col.id, newName);
        await refresh();
        renderColModal();
        if (State.activeRowId) await loadHistory(State.activeRowId);
        toast(`Renamed to "${newName}"`, 'success');
      } catch (err) {
        toast(err.message);
      }
    });

    nameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); renameBtn.click(); }
    });

    // Unique toggle
    const uniqueLbl = document.createElement('label');
    uniqueLbl.className = 'unique-label';
    const uniqueChk = document.createElement('input');
    uniqueChk.type    = 'checkbox';
    uniqueChk.checked = col.is_unique === 1;
    uniqueChk.title   = 'Enforce unique values in this column';
    uniqueChk.addEventListener('change', async () => {
      const newVal = uniqueChk.checked ? 1 : 0;
      try {
        await API.setColumnUnique(col.id, newVal);
        await refresh();
        renderColModal();
        toast(`Unique constraint ${newVal ? 'enabled' : 'disabled'} on "${col.name}"`, 'success');
      } catch (err) {
        uniqueChk.checked = !uniqueChk.checked;
        toast(err.message);
      }
    });
    uniqueLbl.append(uniqueChk, 'Unique');

    // Type selector
    const typeSelect = document.createElement('select');
    typeSelect.className = 'col-type-select';
    typeSelect.title = 'Column type';
    const typeOptions = [
      ['text','Text'],['number','Number'],['boolean','Checkbox'],
      ['date','Date'],['datetime','Date & Time'],['url','URL'],['select','Select']
    ];
    for (const [val, label] of typeOptions) {
      const o = document.createElement('option');
      o.value = val; o.textContent = label;
      if ((col.col_type || 'text') === val) o.selected = true;
      typeSelect.appendChild(o);
    }

    // Choices input (only visible for select type)
    const choicesRow = document.createElement('div');
    choicesRow.className = 'col-choices-row';
    choicesRow.style.display = (col.col_type || 'text') === 'select' ? 'flex' : 'none';
    const choicesLabel = document.createElement('span');
    choicesLabel.style.cssText = 'font-size:11px;color:#64748b;white-space:nowrap';
    choicesLabel.textContent = 'Choices:';
    const choicesInp = document.createElement('input');
    choicesInp.className = 'col-choices-input';
    choicesInp.type = 'text';
    choicesInp.placeholder = 'e.g. Draft, Active, Closed';
    choicesInp.value = col.col_choices || '';
    choicesRow.append(choicesLabel, choicesInp);

    typeSelect.addEventListener('change', () => {
      choicesRow.style.display = typeSelect.value === 'select' ? 'flex' : 'none';
    });

    const typeApplyBtn = document.createElement('button');
    typeApplyBtn.textContent = 'Set';
    typeApplyBtn.className = 'col-action-btn';
    typeApplyBtn.title = 'Apply type change';
    typeApplyBtn.addEventListener('click', async () => {
      const newType = typeSelect.value;
      const newChoices = newType === 'select'
        ? choicesInp.value.split(',').map(s => s.trim()).filter(Boolean).join(',') || null
        : null;
      try {
        await API.setColumnType(col.id, newType, newChoices);
        await refresh();
        renderColModal();
        toast(`Column type set to "${newType}"`, 'success');
      } catch (err) {
        toast(err.message);
      }
    });

    const delBtn = document.createElement('button');
    delBtn.textContent = 'Remove';
    delBtn.className   = 'col-action-btn danger';
    delBtn.addEventListener('click', async () => {
      if (!await showConfirm('Remove Column', `Remove column "${col.name}"? Existing cell data is preserved in history but will no longer appear in the table.`, 'Remove', true)) return;
      try {
        await API.deleteColumn(col.id);
        await refresh();
        renderColModal();
        toast(`Column "${col.name}" removed`, 'success');
      } catch (err) {
        toast(err.message);
      }
    });

    li.append(nameInput, renameBtn, uniqueLbl, typeSelect, typeApplyBtn, delBtn);
    list.appendChild(li);
    // Choices row appended after the li (as a sub-row)
    if (choicesRow) list.appendChild(choicesRow);
  }
}

document.getElementById('btn-manage-cols').addEventListener('click', () => {
  if (!State.activeTableId) return;
  renderColModal();
  document.getElementById('col-modal').showModal();
});

document.getElementById('btn-col-modal-close').addEventListener('click', () => {
  document.getElementById('col-modal').close();
});

document.getElementById('btn-col-add').addEventListener('click', addColumn);
document.getElementById('new-col-name').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { e.preventDefault(); addColumn(); }
});
document.getElementById('new-col-type').addEventListener('change', (e) => {
  document.getElementById('new-col-choices-row').style.display =
    e.target.value === 'select' ? 'flex' : 'none';
});

async function addColumn() {
  const input      = document.getElementById('new-col-name');
  const typeSelect = document.getElementById('new-col-type');
  const uniqueCb   = document.getElementById('new-col-unique');
  const choicesInput = document.getElementById('new-col-choices');
  const name = input.value.trim();
  if (!name) return;
  const col_type   = typeSelect.value;
  const col_choices = col_type === 'select'
    ? choicesInput.value.split(',').map(s => s.trim()).filter(Boolean).join(',') || null
    : null;
  try {
    await API.addColumn(name, uniqueCb.checked ? 1 : 0, col_type, col_choices);
    input.value        = '';
    uniqueCb.checked   = false;
    typeSelect.value   = 'text';
    choicesInput.value = '';
    document.getElementById('new-col-choices-row').style.display = 'none';
    await refresh();
    renderColModal();
    toast(`Column "${name}" added`, 'success');
  } catch (err) {
    toast(err.message);
  }
}

// ---------------------------------------------------------------------------
// Relationships modal
// ---------------------------------------------------------------------------
function renderRelModal() {
  const list = document.getElementById('fk-list');
  list.innerHTML = '';

  if (State.foreignKeys.length === 0) {
    const li = document.createElement('li');
    li.style.cssText = 'color:#94a3b8;font-size:13px;padding:8px 0';
    li.textContent = 'No relationships defined.';
    list.appendChild(li);
  } else {
    for (const fk of State.foreignKeys) {
      const li = document.createElement('li');

      const desc = document.createElement('span');
      desc.className = 'fk-desc';
      desc.textContent = fk.from_column_name;

      const arrow = document.createElement('span');
      arrow.className = 'fk-arrow';
      arrow.textContent = 'â†’';

      const target = document.createElement('span');
      target.style.cssText = 'color:#8b5cf6;font-weight:600';
      target.textContent = fk.to_table_name;

      const delBtn = document.createElement('button');
      delBtn.className   = 'col-action-btn danger';
      delBtn.textContent = 'Remove';
      delBtn.addEventListener('click', async () => {
        try {
          await API.deleteForeignKey(fk.id);
          await refresh();
          renderRelModal();
          toast('Relationship removed', 'success');
        } catch (err) {
          toast(err.message);
        }
      });

      li.append(desc, arrow, target, delBtn);
      list.appendChild(li);
    }
  }

  // Populate "from column" dropdown â€” only columns without an existing FK
  const existingFkColIds = new Set(State.foreignKeys.map(fk => fk.from_column_id));
  const fromSel = document.getElementById('fk-from-col');
  fromSel.innerHTML = '<option value="">â€” select column â€”</option>';
  for (const col of State.columns) {
    if (!existingFkColIds.has(col.id)) {
      const opt = document.createElement('option');
      opt.value = col.id;
      opt.textContent = col.name;
      fromSel.appendChild(opt);
    }
  }

  // Populate "to table" dropdown â€” all other live tables
  const toSel = document.getElementById('fk-to-table');
  toSel.innerHTML = '<option value="">â€” select table â€”</option>';
  for (const tbl of State.tables) {
    if (tbl.id !== State.activeTableId) {
      const opt = document.createElement('option');
      opt.value = tbl.id;
      opt.textContent = tbl.name;
      toSel.appendChild(opt);
    }
  }
}

document.getElementById('btn-relationships').addEventListener('click', () => {
  if (!State.activeTableId) return;
  renderRelModal();
  document.getElementById('relationships-modal').showModal();
});

document.getElementById('btn-rel-modal-close').addEventListener('click', () => {
  document.getElementById('relationships-modal').close();
});

document.getElementById('btn-fk-add').addEventListener('click', async () => {
  const fromColId = parseInt(document.getElementById('fk-from-col').value);
  const toTableId = parseInt(document.getElementById('fk-to-table').value);
  if (!fromColId || !toTableId) {
    toast('Select both a column and a target table');
    return;
  }
  try {
    await API.addForeignKey(fromColId, toTableId);
    await refresh();
    renderRelModal();
    toast('Relationship added', 'success');
  } catch (err) {
    toast(err.message);
  }
});

// ---------------------------------------------------------------------------
// Refresh
// ---------------------------------------------------------------------------
async function refresh() {
  State.tables = await API.getTables();
  renderSidebar();

  // Ensure activeTableId is still valid
  if (State.activeTableId !== null) {
    if (!State.tables.find(t => t.id === State.activeTableId)) {
      State.activeTableId = State.tables.length > 0 ? State.tables[0].id : null;
    }
  }
  // Auto-select first table on first load
  if (State.activeTableId === null && State.tables.length > 0) {
    State.activeTableId = State.tables[0].id;
    _setActionButtonsDisabled(false);
  }

  _updateToolbarTitle();

  if (State.activeTableId === null) {
    State.columns     = [];
    State.rows        = [];
    State.foreignKeys = [];
    State.fkOptionsMap = {};
    _setActionButtonsDisabled(true);
    renderSidebar();
    renderTable();
    return;
  }

  const [columns, rows, foreignKeys] = await Promise.all([
    API.getColumns(),
    API.getRows(),
    API.getForeignKeys(),
  ]);
  State.columns     = columns;
  State.rows        = rows;
  State.foreignKeys = foreignKeys;

  // Fetch FK options for all FK columns in parallel
  const fkColIds = foreignKeys.map(fk => fk.from_column_id);
  const fkOptionResults = await Promise.all(fkColIds.map(id => API.getFkOptions(id)));
  State.fkOptionsMap = {};
  fkColIds.forEach((id, i) => { State.fkOptionsMap[id] = fkOptionResults[i]; });

  renderSidebar();
  renderTable();
}

// refresh() is triggered by the worker's 'ready' message
</script>
</body>
</html>
